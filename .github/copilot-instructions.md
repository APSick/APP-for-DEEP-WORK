# Инструкции для Copilot по deepwork-tma

## Обзор проекта
Это **Telegram Mini App (TMA)** для отслеживания продуктивности и сеансов глубокой работы. Приложение включает таймер в стиле Помодоро с двумя режимами (секундомер/обратный отсчет), управление проектами, историю сеансов и интеграцию с Telegram Web App API.

## Архитектура и ключевые компоненты

### Управление состоянием (src/App.tsx)
Приложение — это однокомпонентное React-приложение, управляющее сложным состоянием таймера:
- **Архитектура таймера**: Двухфазная система (фокус/перерыв), где каждая фаза имеет:
  - `stopwatch` режим: отслеживание прошедшего времени с нуля
  - `countdown` режим: оставшееся время до завершения
  - Активный таймер переключается через поле `active: TimerKind`
  - Расчеты времени используют `nowMs` (текущее время) для обеспечения точности в реальном времени при паузе/возобновлении
- **Состояние на основе фаз**: `phase: Phase` отслеживает "focus" или "break" с объектами `timers.focus` и `timers.break` типа PhaseTimer
- **Версионирование снимков**: Состояние таймера сохраняется как `TimeModeSnapshotV2` ({ v: 2, phase, focus, break }), обеспечивая безопасные миграции схемы

### Слой данных (src/storage.ts)
Постоянное хранилище с поддержкой миграций:
- **Паттерн ключей**: Все ключи localStorage имеют префикс `dw_` и версию (например, `dw_time_mode_v2`)
- **Безопасный парсинг**: Обертка `safeJsonParse<T>()` корректно обрабатывает поврежденные данные
- **Данные по умолчанию**: Проекты и данные сеансов автоматически инициализируются с разумными значениями по умолчанию, если localStorage пуст
- **Генерация ID**: `uid()` объединяет случайное число + временную метку для создания уникальных ID сеансов

### Интеграция с Telegram (src/telegram.ts)
- Функция-обертка `getTg()` получает доступ к `window.Telegram.WebApp`
- Скрипт загружается в `index.html`: `<script src="https://telegram.org/js/telegram-web-app.js"></script>`
- Вызывается в App.tsx: `tg.ready()` и `tg.expand()` при монтировании

### Система типов (src/storage.ts)
Основные типы определяют модель данных:
```typescript
Session: { id, type: Phase, task, startedAt, endedAt, durationSec, projectId, projectName }
PhaseTimer: { active: TimerKind, countdownMin, stopwatch, countdown }
Project: { id, name }
```

## Рабочие процессы разработки

### Настройка и разработка
```bash
pnpm dev          # Vite dev сервер с HMR (http://localhost:5173)
pnpm build        # tsc -b && vite build (выходные файлы в dist/)
pnpm lint         # ESLint проверка всех .{ts,tsx} файлов
pnpm preview      # Предпросмотр production сборки локально
```

### TypeScript и сборка
- **Проверка типов**: Запустить перед сборкой с помощью `tsc -b` (соблюдает tsconfig.app.json и tsconfig.node.json)
- **Конфигурация Vite**: Минимальная настройка в vite.config.ts с использованием @vitejs/plugin-react для Fast Refresh
- **Версия React**: React 19.2.0 (последняя стабильная версия) — избегайте старых паттернов

### Конфигурация ESLint
- Использует новый flat config формат (eslint.config.js)
- Включает плагины react-hooks и react-refresh
- Расширяйте type-aware правилами если нужно (см. README шаблон)

## Паттерны проекта

### Паттерн расчета времени таймера
При работе с состоянием таймера всегда:
1. Сохраняйте базовое время + метку времени начала: `baseSec` + `startedAt` (мс)
2. Рассчитывайте прошедшее время: `baseSec + Math.floor((nowMs - startedAt) / 1000)` для режима секундомера
3. Оставшееся время: `baseRemainingSec - Math.floor((nowMs - startedAt) / 1000)` для режима обратного отсчета
4. Используйте `Math.max(0, remaining)` для предотвращения отрицательных значений при завершении обратного отсчета
_См. calcStopwatchSec() и calcCountdownRemaining() в App.tsx_

### Паттерн сохранения состояния
Для любых новых постоянных данных:
1. Определите ключ хранилища с версией: `const KEY_X = "dw_x_v1"`
2. Создайте функции загрузки/сохранения: `loadX()` с `safeJsonParse<T>()`, `saveX(data)`
3. Используйте `useEffect(() => save(), [data])` для синхронизации состояния с localStorage
4. Инициализируйте состояние в `useState(() => load())` для загрузки из хранилища
_См. функции storage.ts и инициализацию данных в App.tsx_

### Навигация по вкладкам
Вкладки управляются состоянием `tab: Tab`, где `Tab = "focus" | "music" | "stats" | "profile"`. Интерфейс каждой вкладки отрисовывается условно на основе этой одной переменной состояния.

## Точки интеграции

### Внешние зависимости
- **React 19** с React DOM для рендеринга UI
- **Telegram Web App API** (window.Telegram.WebApp, внедряется платформой TMA)
- **Vite** для сборки; настроена бета версия v8 (см. pnpm overrides в package.json)

### Поток данных
1. Взаимодействие пользователя → обновление состояния React
2. Изменение состояния → useEffect сохраняет в localStorage
3. LocalStorage сохраняется при перезагрузке приложения
4. Тик таймера обновляет `nowMs` каждые 250мс (только если активен какой-либо таймер)
5. Отображение рассчитывается из `nowMs` + сохраненных базовых времён

### Без внешнего бэкенда
- Все данные находятся на стороне клиента (только localStorage)
- Состояние таймера хранится в памяти; сохраняется при каждом изменении
- Нет API вызовов — чисто локальные вычисления

## Справочник ключевых файлов
- **[src/App.tsx](../src/App.tsx)** — Главный компонент со всем UI и логикой таймера (728 строк)
- **[src/storage.ts](../src/storage.ts)** — Типы данных и слой сохранения
- **[src/telegram.ts](../src/telegram.ts)** — Обертка Telegram Web App
- **[vite.config.ts](../vite.config.ts)** — Минимальная конфигурация Vite
- **[index.html](../index.html)** — Внедрение скрипта Telegram Web App
- **[src/App.css](../src/App.css)** — Стили компонента
- **[src/index.css](../src/index.css)** — Глобальные стили

## Типичные задачи разработки

- **Добавить новый режим таймера**: Расширьте тип `TimerKind`, добавьте в настройку PhaseTimer
- **Добавить постоянные данные**: Создайте константу ключа + функции загрузки/сохранения в storage.ts, подключите в App.tsx через useEffect
- **Отладка состояния таймера**: Проверьте состояние `timers[phase].stopwatch/countdown` и убедитесь, что `nowMs` обновляется (инспектируйте каждые 250мс)
- **Интеграция с Telegram**: Получите доступ к `tg` через `getTg()` в App.tsx; оборачивайте в try-catch для тестирования в веб-версии
